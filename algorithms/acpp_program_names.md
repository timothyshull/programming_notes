Program 1.1 - Quick-find solution to connectivity problem
Program 1.2 - Quick-union solution to connectivity problem
Program 1.3 - Weighted version of quick union
Program 1.4 - Path compression by halving
Program 2.1 - Sequential search
Program 2.2 - Binary search **
Program 3.1 - Function definition
Program 3.2 - Types of numbers
Program 3.3 - Point data type interface
Program 3.4 - Point data type implementation
Program 3.5 - Sieve of Eratosthenes
Program 3.6 - Dynamic memory allocation for an array
Program 3.7 - Coin flipping simulation
Program 3.8 - Closest point computation
Program 3.9 - Circular list example (Josephus problem)
Program 3.10 - List reversal
Program 3.11 - List insertion sort
Program 3.12 - List processing interface
Program 3.13 - List allocation for the Josephus problem
Program 3.14 - Implementation of list-processing interface
Program 3.15 - String search
Program 3.16 - Two-dimensional array allocation
Program 3.17 - Sorting an array of strings
Program 3.18 - Adjacency matrix graph representation
Program 3.19 - Adjacency lists graph representation
Program 3.20 - A two-dimensional array of lists
Program 4.1 - Point class implementation
Program 4.2 - Point client (closest-point computation)
Program 4.3 - Point ADT interface
Program 4.4 - Pushdown-stack ADT interface
Program 4.5 - Postfix-expression evaluation
Program 4.6 - Infix-to-postfix conversion
Program 4.7 - Array implementation of a pushdown stack
Program 4.8 - Linked-list implementation of a pushdown stack
Program 4.9 - Equivalence relations ADT interface
Program 4.10 - Equivalence relations ADT client
Program 4.11 - Equivalence relations ADT implementation
Program 4.12 - Abstract class for equivalence relations
Program 4.13 - FIFO queue ADT interface
Program 4.14 - FIFO queue linked-list implementation
Program 4.15 - FIFO queue array implementation
Program 4.16 - Stack with index items and no duplicates
Program 4.17 - Complex numbers driver (roots of unity)
Program 4.18 - First-class ADT interface for complex numbers
Program 4.19 - First-class ADT for complex numbers
Program 4.20 - Queue client program (queue simulation)
Program 4.21 - First-class queue ADT interface
Program 4.22 - Linked-list implementation of a first-class queue
Program 4.23 - Polynomial client (binomial coefficients)
Program 4.24 - ADT interface for polynomials
Program 4.25 - Array implementation of polynomial ADT
Program 5.1 - Factorial function (recursive implementation)
Program 5.2 - A questionable recursive program
Program 5.3 - Euclid's algorithm
Program 5.4 - Recursive program to evaluate prefix expressions
Program 5.5 - Examples of recursive functions for linked-lists
Program 5.6 - Divide-and-conquer to find the maximum
Program 5.7 - Solution to the towers of Hanoi
Program 5.8 - Divide and conquer to draw a ruler
Program 5.9 - Nonrecursive program to draw a ruler
Program 5.10 - Fibonacci numbers (recursive implementation)
Program 5.11 - Fibonacci numbers (dynamic programming)
Program 5.12 - Knapsack problem (recursive implementation)
Program 5.13 - Knapsack problem (dynamic programming)
Program 5.14 - Recursive tree traversal
Program 5.15 - Preorder traversal (nonrecursive) **
Program 5.16 - Level-order traversal **
Program 5.17 - Computation of tree parameters
Program 5.18 - Quick tree-print function // inorder traversal **
Program 5.19 - Construction of a tournament
Program 5.20 - Construction of a parse tree
Program 5.21 - Depth-first search
Program 5.22 - Breadth-first search
Program 6.1 - Example of array sort with driver program
Program 6.2 - Selection sort
Program 6.3 - Insertion sort
Program 6.4 - Bubble sort
Program 6.5 - Shellsort
Program 6.6 - Sort driver for arrays
Program 6.7 - Interface for array data type
Program 6.8 - Implementation of array data type
Program 6.9 - Sample for item data type
Program 6.10 - Sample implementation for item data type
Program 6.11 - Data-type implementation for string items
Program 6.12 - Data-type interface for record items
Program 6.13 - Data-type implementation for record items
Program 6.14 - In-place sort
Program 6.15 - Linked-list type interface
Program 6.16 - Linked-list selection sort
Program 6.17 - Key-indexed counting
Program 7.1 - Quicksort **
Program 7.2 - Partitioning **
Program 7.3 - Nonrecursive quicksort **
Program 7.4 - Improved quicksort **
Program 7.5 - Quicksort with three-way partitioning **

Program 8.6 - Selection
Program 8.7 - Nonrecursive selection

Program 8.1 - Merging
Program 8.2 - Abstract in-place merge
Program 8.3 - Top-down mergesort
Program 8.4 - Mergesort
Program 8.5 - Bottom-up mergesort
Program 8.6 - Linked-list merge
Program 8.7 - Top-down list mergesort
Program 8.8 - Bottom-up list mergesort
Program 9.1 - Basic priority-queue ADT
Program 9.2 - Array implementation of a priority queue
Program 9.3 - Bottom-up heapify
Program 9.4 - Top-down heapify
Program 9.5 - Heap-based priority queue
Program 9.6 - Sorting with a priority queue
Program 9.7 - Heapsort
Program 9.8 - Full priority-queue ADT
Program 9.9 - Unordered doubly-linked-list priority queue
Program 9.10 - Full priority-queue ADT
Program 9.11 - Unordered doubly-linked list priority queue
Program 9.12 - Index-heap-based priority queue
Program 9.13 - Joining of two equal-sized power-of-2 heaps
Program 9.14 - Insertion into a binomial queue
Program 9.15 - Removal of the maximum in a binomial queue
Program 9.16 - Joining (merging) of two binomial queues
Program 10.1 - Binary quicksort
Program 10.2 - MSD radix sort
Program 10.3 - Three-way-radix quicksort
Program 10.4 - LSD radix sort
Program 11.1 - Perfect shuffle and perfect unshuffle
Program 11.2 - Batcher's odd-even merge (recursive version)
Program 11.3 - Batcher's odd-even merge (nonrecursive version)
Program 11.4 - Batcher's odd-even sort (nonrecursive version)
Program 12.1 - Sample implementation for item ADT
Program 12.2 - Symbol-table abstract data type
Program 12.3 - Example of a symbol-table client
Program 12.4 - Key-indexed array based symbol table
Program 12.5 - Array-based symbol table (ordered)
Program 12.6 - Linked-list-based symbol table
Program 12.7 - Binary search (for array-based symbol table)
Program 12.8 - BST-based symbol table
Program 12.9 - Sorting with a BST
Program 12.10 - Insertion in BSTs (nonrecursive)
Program 12.11 - Example of indexing a text string
Program 12.12 - Rotations in BSTs
Program 12.13 - Root insertion in BSTs
Program 12.14 - Selection with a BST
Program 12.15 - Partitioning of a BST
Program 12.16 - Removal of a node with a given key in a BST
Program 12.17 - Joining of two BSTs
Program 13.1 - Balancing a BST (!!!)
Program 13.2 - Randomized BST
Program 13.3 - Randomized BST combination
Program 13.4 - Deletion in a randomized BST
Program 13.5 - Splay insertion in BSTs
Program 13.6 - Insertion in red-black BSTs
Program 13.7 - Searching in skip lists
Program 13.8 - Skip-list data structures and constructor
Program 13.9 - Insertion in skip lists
Program 13.10 - Removal in skip lists
Program 14.1 - Hash function for string keys
Program 14.2 - Universal hash function (for string keys)
Program 14.3 - Hashing with separate chaining
Program 14.4 - Linear probing
Program 14.5 - Removal from a linear probing hash table
Program 14.6 - Double hashing
Program 14.7 - Dynamic hash insertion (for linear probing)
Program 15.1 - Binary digital search tree
Program 15.2 - Trie search
Program 15.3 - Trie insertion
Program 15.4 - Patricia-trie search
Program 15.5 - Patricia-trie insertion
Program 15.6 - Patricia-trie sort
Program 15.7 - Existence-trie search and insertion
Program 15.8 - Existence-TST search and insertion
Program 15.9 - Partial-match searching in TSTs
Program 15.10 - Hybrid TST node-type definitions
Program 15.11 - Hybrid TST insertion for symbol-table ADT
Program 15.12 - Hybrid TST search for symbol-table ADT
Program 16.1 - B-tree node-type definitions
Program 16.2 - B-tree search
Program 16.3 - B-tree insertion
Program 16.4 - B-tree node split
Program 16.5 - Extendible hashing data structures
Program 16.6 - Extendible hashing search
Program 16.7 - Extendible hashing insertion
Program 16.8 - Extendible hashing directory insertion


Program 17.1 - Graph ADT interface
Program 17.2 - Example of a graph-processing client
Program 17.3 - A client function that prints a graph **
Program 17.4 - Graph-processing input/output interface
Program 17.5 - Connectivity interface
Program 17.6 - Example of a graph-processing client program
Program 17.7 - Graph ADT implementation (adjacency matrix)
Program 17.8 - Iterator for adjacency-matrix representation
Program 17.9 - Graph ADT implementation (adjacency lists)
Program 17.10 - Iterator for adjacency-lists representation
Program 17.11 - Vertex degrees class implementation
Program 17.12 - Random graph generator (random edges)
Program 17.13 - Random graph generator (random graph)
Program 17.14 - Building a graph from pairs of symbols
Program 17.15 - Symbol indexing for vertex names
Program 17.16 - Simple path search
Program 17.17 - Hamilton path
Program 17.18 - Euler path existence
Program 17.19 - Linear-time Euler path
Program 18.1 - Depth-first search of a connected component
Program 18.2 - Graph search
Program 18.3 - Derived class for depth-first search
Program 18.4 - Graph connectivity
Program 18.5 - Two-way Euler tour
Program 18.6 - Two-colorability
Program 18.7 - Edge connectivity
Program 18.8 - Breadth-first search
Program 18.9 - Improved BFS
Program 18.10 - Generalized graph search
Program 18.11 - Random queue implementation
Program 19.1 - Reversing a digraph
Program 19.2 - DFS of a digraph
Program 19.3 - Warshall's algorithm
Program 19.4 - DFS-based transitive closure
Program 19.5 - Representing a binary tree with a binary DAG
Program 19.6 - Reverse topological sort **
Program 19.7 - Topological sort **
Program 19.8 - Source-queue-based topological sort **
Program 19.9 - Transitive closure of a DAG
Program 19.10 - Strong components (Kosaraju's algorithm)
Program 19.11 - Strong components (Tarjan's algorithm)
Program 19.12 - Strong components (Gabow's algorithm)
Program 19.13 - Strong-component-based transitive closure
Program 20.1 - ADT interface for graphs with weighted edges
Program 20.2 - Example of a graph-processing client function
Program 20.3 - Weighted-graph class (adjacency matrix)
Program 20.4 - Iterator class for adjacency-matrix representation
Program 20.5 - Weighted-graph class (adjacency lists)
Program 20.6 - Prim's MST algorithm
Program 20.7 - Priority first search
Program 20.8 - Kruskal's MST algorithm
Program 20.9 - Boruvka's MST algorithm
Program 20.10 - Multiway heap priority queue implementation
Program 21.1 - Dijkstra's algorithm (priority-first search)
Program 21.2 - All-pairs shortest-paths ADT
Program 21.3 - Computing the diameter of a network
Program 21.4 - Dijkstra's algorithm for all shortest paths
Program 21.5 - Floyd's algorithm for all shortest paths
Program 21.6 - Longest paths in an acyclic network
Program 21.7 - All shortest paths in an acyclic network
Program 21.8 - Job scheduling
Program 21.9 - Bellman-Ford algorithm
Program 22.1 - Flow check and value computation
Program 22.2 - Flow-network edges
Program 22.3 - Augmenting-paths maxflow implementation
Program 22.4 - PFS for augmenting-paths implementation
Program 22.5 - Preflow-push maxflow implementation
Program 22.6 - Feasible flow via reduction to maxflow
Program 22.7 - Bipartite matching via reduction to maxflow
Program 22.8 - Computing flow cost
Program 22.9 - Residual networks (cycle canceling)
Program 22.10 - Vertex potential calculation
Program 22.11 - Augmenting along a cycle
Program 22.12 - Spanning tree substitution
Program 22.13 - Eligible edge search
Program 22.14 - Network simplex (basic implementation)
Program 22.15 - Network simplex (improved implementation)
